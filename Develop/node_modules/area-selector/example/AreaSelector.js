import React, { Component } from 'react';
import {
  Text,
  View,
  Dimensions,
  TouchableHighlight,
  Alert,
  Modal,
  TextInput,
  Slider,
  Navigator,
  Image
} from 'react-native';

import turf from '@turf/turf'
import GeoToCart from './Utilities/GeoToCart'

const { width, height } = Dimensions.get('window');
var MapView = require('react-native-maps')
import RNViewShot from "react-native-view-shot";

// Shortened variables to hold type of Drawing

var FH = false  // Free Hand
var FL = false  // Free Liner
var PL = false  // Poly Line
var PG = false  // PolyGon
var DM = false  // Drop Marker
var CR = false  // Circle
var drawMode = false // will be assigned later assigned to this.props.drawMode
var editMode = false // will be assigned later assigned to this.props.editMode

var drawWithInLocalShape

var print = function(a,b,c,d,e,f){
 //   console.log('%c Map:','background: coral; color: white',
 //   checkUndefined(a),
 //   checkUndefined(b),
 //   checkUndefined(c),
 //   checkUndefined(d),
 //   checkUndefined(e),
 //   checkUndefined(f)
 // )
}
var checkUndefined = function(argument) {
    if( argument == undefined) {
      return ''
    }
    return argument
}

class AreaSelector extends Component {

    constructor(props) {
    super(props);
    this.mapReference = {}
    this.newRegion = {}
    this.state =  {
         region:{
           latitude:0,
           longitude:0,
           latitudeDelta:180,
           longitudeDelta:180
         },
         polygonShape : {
           coordinates : []
         },
         circleShape : {
           coordinates : [],
           radius : 0
         },
         markers:[],
         imageSrc:"https://i.imgur.com/5EOyTDQ.jpg",
         randPoly: [
            {latitude:10,longitude:40},
            {latitude:10,longitude:20},
            {latitude:30,longitude:20},
            {latitude:30,longitude:40}
          ],
         drawWithInShape: [],
         dragglebleMarkers: [],
       }
  }

  componentWillMount() {
    //converting regular shape into turf shape to evaluate the point within the supplied shape.
    this.setState({
      dragglebleMarkers : this.props.dragglebleMarkers//this.props.dragglebleMarkers
    })
    this._updateDrawType(this.props)
  }

  componentDidMount = () => {
    // As per use Case you can set the user Location as Map Mounts
    // this.userLocation()
  }

  snap = () => {
        //Disabling the Snap Temporarily
      if (!this.props.drawMode && 0) {
          RNViewShot.takeSnapshot(this.mapReference, {
          format: "png",
          quality: 0.8
        })
        .then((res) => {
          //console.log('Image source Updated',res);
          this.setState({
            imageSrc:res
          })
        })
      }
  }

  getSnap = () =>{
    return this.state.imageSrc
  }


  userLocation = () =>{
    navigator.geolocation.getCurrentPosition(
      (position) => {
        this.mapReference.animateToRegion(
          {
            latitudeDelta : 0.0001,
            longitudeDelta : 0.0001,
            latitude : position.coords.latitude,
            longitude : position.coords.longitude
          } , 500 )
      },
      (error) => alert(JSON.stringify(error)),
      // params Support only for Android
      {enableHighAccuracy: true, timeout: 20000, maximumAge: 1000}
    );
  }

  play = () => {
    print('Play Button Clicked')
    var region = {
     latitude: 44.883681,
     longitude:  -0.171728,
     latitudeDelta:0.01,
     longitudeDelta: 0.01,
    }
    this.mapReference.animateToRegion(region,500)
  }

  _drawPoint = (newPoint) =>{
      if(!this.props.editMode) {
            if(CR) {
                  var newCircle = {
                        coordinates : [newPoint],
                        radius : this.state.circleShape.radius
                      }

                  this.setState({circleShape: newCircle})

            } else if(FH || PL || PG || FL) {
                  this.setState({
                        polygonShape: {
                              coordinates : [...this.state.polygonShape.coordinates,newPoint]
                        }
                })
            } else {
                  this.setState({
                        markers : [...this.state.markers,{coordinates:newPoint}]
                      })
          }
      }
  }

  _handleNewPoint = (newPoint) => {
        if(this.props.drawWithInShape.length > 3){
          /* check if the drawWithInShape is supplied and is a Polygon, if not supplied, this.props.drawWithInShape defaults to []
           and length is suppose to be more than 3 to form a polygon

           if drawWithInShapeis supplied and form a polygon, check if every new point falls with in the supplied shape,
           if not do not add the point and thrown a warning.
              */
            if(turf.inside(GeoToCart(newPoint), this.state.drawWithInShape)) {
                  this._drawPoint(newPoint)
              } else {
                  //console.warn('ooops, you are way too greedy')
              }
        } else {
            this._drawPoint(newPoint)
        }

 }

join = () => {
   if(!CR && this.state.polygonShape.coordinates.length > 2){
      if(this.state.polygonShape.coordinates[0].latitude != this.state.polygonShape.coordinates[this.state.polygonShape.coordinates.length - 1].latitude){
        var appendStartPointToEnd = this.state.polygonShape.coordinates.concat(this.state.polygonShape.coordinates[0])
            var joinedPolygon = {
              coordinates: appendStartPointToEnd
            }
           this.setState({
              polygonShape: joinedPolygon
           })
        print('Joining First and Last Coordinates to form Closed Area');
      }else {
        print('Already Joined')
      }
   }else{
     Alert.alert('Join','Add 3 or more points to join')
   }
 }

data = () =>  {
  if(this.props.drawMode) {
    if( CR ) {
      return {
        id : Date.now(),  // Asigning a Unique Id to prevent duplicate data
        type : 'circle',
        data : this.state.circleShape
      }
    } else if( PL || PG || FL || FH ){
      return {
        id : Date.now(),
        type : 'polygon',
        data :this.state.polygonShape
      }
    } else {
      return {
        id : Date.now(),
        type : 'markers',
        data :this.state.markers
      }
    }
  }
  return null
}

  _updateDrawType = (newProps) =>{
        FH = (newProps.drawType == 'freeHand')
        FL = (newProps.drawType == 'freeLiner')
        PL = (newProps.drawType == 'polyline')
        PG = (newProps.drawType == 'polygon')
        DM = (newProps.drawType == 'dropMarker')
        CR = (newProps.drawType == 'circle')
        drawMode = this.props.drawMode
        editMode = this.props.editMode
        this.setState({
          drawWithInShape : newProps.drawWithInShape.length
                            ? GeoToCart(newProps.drawWithInShape)
                            : []
        })
  }

  log(){
    // console.log('Free Hand',FH);
    // console.log('Free Liner',FL);
    // console.log('Poly Line',PL);
    // console.log('Poly Gon',PG);
    // console.log('Drop Marker',DM);
  }

componentWillReceiveProps = (newProps) => {
  print('Receive new Props',newProps.shapes)
  this._updateDrawType(newProps)
}

_handleMarkerDrag = (newCords, initialLat, initialLng, index) => {
    //console.log('Marker Moved at',index);
    //console.log('Moved to ', newCords ,'moved from',initialLat,initialLng)
    var cordsObj = {coordinates:{latitude:newCords.latitude, longitude:newCords.longitude}}
    var alteredMarkersPostions = JSON.parse(JSON.stringify(this.state.dragglebleMarkers))
    alteredMarkersPostions[index].coordinates = newCords
    this.setState({
      dragglebleMarkers : alteredMarkersPostions
    })
    //console.log('Existing Marker Postion', JSON.stringify(this.state.dragglebleMarkers[index]));
    //console.log('New Marker Postion', JSON.stringify(alteredMarkersPostions[index]));
}

_editableMarkersLayer = () => {
  if(this.props.editMode){
      if( PL || PG ) {
        return(
          this.state.polygonShape.coordinates.map( (eachMarker,i) => {
            return(
                <MapView.Marker
                  key = { i }
                  coordinate = { eachMarker }
                  onDragEnd = {(e) => {
                      this._handleMarkerMove(
                        e.nativeEvent.coordinate,
                        eachMarker.latitude,
                        eachMarker.longitude
                      )}}
                  draggable
                />
            );
          })
        )
      }else if ( DM ) {
        return(
          this.state.markers.map( (eachMarker,i) => {
            return(
                <MapView.Marker
                  key = { i }
                  coordinate = { eachMarker.coordinates }
                  pinColor = {'yellow'}
                  onDragEnd = {(e) => {
                      this._handleMarkerMove(
                        e.nativeEvent.coordinate,
                        eachMarker.coordinates.latitude,
                        eachMarker.coordinates.longitude
                      )}}
                  draggable
                />
            );
          })
        )
      }
  }
  return null
}

_elementsLayer = () => {
  //console.log('Draw Type', this.props.drawType);
  if(this.props.drawMode){
      print('Drawing Type Detected As:',this.props.drawType)
      switch (this.props.drawType) {
        case 'polyline':
        case 'freeHand':
        case 'freeLiner':
            return (
                <MapView.Polyline
                //key={polyline.id}
                geodesic ={false}
                showsUserLocation={true}
                coordinates={this.state.polygonShape.coordinates}
                strokeColor="#1fca23"
                strokeWidth={5}/>
            )
          break;
        case 'polygon':
            if(this.state.polygonShape.coordinates.length > 2 ){
                return (
                    <MapView.Polygon
                    coordinates={this.state.polygonShape.coordinates}
                    fillColor ='rgba(24,158,27,0.5)'
                    strokeColor="#1fca23"
                    strokeWidth={6}
                    />
                  )
            } else {
                return (
                    <MapView.Polyline
                    geodesic ={false}
                    coordinates={this.state.polygonShape.coordinates}
                    strokeColor="#1fca23"
                    strokeWidth={5}/>
                  )
            }
            return null
          break;
        case 'circle':
            if(this.state.circleShape.coordinates.length != 0){
              return (
                  <MapView.Circle
                    center={{
                        latitude:this.state.circleShape.coordinates[0].latitude,
                        longitude:this.state.circleShape.coordinates[0].longitude
                    }}
                    radius = {this.state.circleShape.radius}
                    fillColor = 'transparent'
                    strokeColor = "#1fca23"
                    strokeWidth = {6}
                    />
              )
            } else {
              return null
            }
          break;
        case'dropMarker':
              return (
                this.state.markers.map((eachMarker,i) => {
                  if(!this.props.editMode){
                      return(
                        <MapView.Marker
                          key = { i }
                          coordinate = {eachMarker.coordinates}
                          />
                      )
                  }else {
                    return null
                  }

                })
              )
          break
        default:
          return null
      }
  }

  return null
}

reset = () => {
    this.setState({
        polygonShape: {
            coordinates: []
        },
        circleShape : {
          coordinates : [],
          radius : 0
        },
        markers : []
    })
}

undo = () => {
   if(this.state.polygonShape.coordinates.length != 0){
     var undoPolygonShape = {
            coordinates: this.state.polygonShape.coordinates.slice(0,-1)
          }
        this.setState({
          polygonShape:undoPolygonShape
        })
   }
}


_draggableMarkersLayer = () => {
  return(
    this.state.dragglebleMarkers.map((eachDrabbleMarker,i) => {
        return(
          <MapView.Marker
            //image = {eachDrabbleMarker.image}
            key = { i }
            coordinate = { eachDrabbleMarker.coordinates }
            //onPress = { ()=>this.props.onMarkerClick(eachDrabbleMarker) }
            //onSelect = { ()=>this.props.onMarkerClick(eachDrabbleMarker) }
            onDragEnd = {(e) => {
                this._handleMarkerDrag(
                  e.nativeEvent.coordinate,
                  eachDrabbleMarker.coordinates.latitude,
                  eachDrabbleMarker.coordinates.longitude,
                  i
                )}}
            draggable
          />
        )
    })
  )
}

_handleMarkerMove = (newLatLng,initialLat,initialLng) => {
    if( PL || PG || FL ){
      var currentPolylineData = this.state.polygonShape.coordinates
      var modifiedPolylineData = []

      for(var key in currentPolylineData){
        if(currentPolylineData[key].latitude == initialLat && currentPolylineData[key].longitude == initialLng){
            modifiedPolylineData[key] = newLatLng
        } else {
            modifiedPolylineData[key] = currentPolylineData[key]
        }
      }

      this.setState({
          polygonShape : {
            coordinates : modifiedPolylineData
          }
      })
    }else if( DM ) {
      var currentMarkersPositions = this.state.markers
      var modifiedMarkersPositions = []

      for( var index in currentMarkersPositions ) {
        //console.log('currentMarkersPositions',currentMarkersPositions[index]);
          if( currentMarkersPositions[index].coordinates.latitude == initialLat &&
              currentMarkersPositions[index].coordinates.longitude == initialLng ){
                var newCords = {
                    coordinates: {
                      latitude : newLatLng.latitude,
                      longitude : newLatLng.longitude
                    }
                  }
                modifiedMarkersPositions.push(newCords)
          } else{
                modifiedMarkersPositions.push(currentMarkersPositions[index])
          }
      }
        //console.log('currentMarkersPositions', JSON.stringify(currentMarkersPositions))
        //console.log('modifiedMarkersPositions',JSON.stringify(modifiedMarkersPositions))
      this.setState({
        markers : modifiedMarkersPositions
      })

      //console.log('initial LatLngs',initialLat, initialLng);
      //console.log('New LatLngs',newLatLng.longitude, newLatLng.latitude);
    }

}

  // done = () => {
  //   console.log('done trigger');
  //     this.setState({
  //        polygonShape : {
  //          coordinates : []
  //        },
  //        circleShape : {
  //          coordinates : [],
  //          radius : 0
  //        },
  //        markers : []
  //      },()=>{this.snap()})
  //  }

   goto = (region) => {
     // Pass the Region to animate to the region
     /*
     Example Region object
     {
       latitudeDelta : 0.0001,
       longitudeDelta : 0.0001,
       latitude : 50,
       longitude : 50
     }
     */
     this.mapReference.animateToRegion( region , 500 )

   }

   dropPins = (Image) => {

      //@TODO This Method drop the pins on the Map

   }

   setRadius = (r) => {
     //console.log('Income Radius Value', r);
     this.setState({
       circleShape: {
         coordinates : this.state.circleShape.coordinates,
         radius : r
       }
     })
   }

   _drawWithInLayer() {
     if(this.props.drawWithInShape && this.props.drawWithInShape.length > 3) {
          return(
                <MapView.Polygon
                  coordinates={this.props.drawWithInShape}
                  //fillColor ="rgba(24,158,27,0.5)"
                  strokeColor="rgba(24,158,27,0.5)"
                  strokeWidth={0}
                />
          )
     } else return null
   }

   _handlePolyOnPress = (clickedPoly) => {
     // Check to see if the onPress property is added while creating the polygon Object.
     if('onPress' in clickedPoly && false) {
          clickedPoly.onPress(clickedPoly)
     }
   }

   _handleZoom = (LatDelta,LngDelta) => {
     if( LatDelta > 0 && LngDelta > 0 && LatDelta < 180 && LngDelta < 180 ) {
       this.mapReference.animateToRegion({
          latitude: this.newRegion.latitude,
          longitude: this.newRegion.longitude,
          latitudeDelta:LatDelta,
          longitudeDelta:LngDelta
        },100)
     }
   }

   zoomIn = () => {
     // Delta Value halfs while Zomming In
     this._handleZoom(this.newRegion.latitudeDelta/2,this.newRegion.longitudeDelta/2)
   }

   zoomOut = () => {
      // Delta Value doubles while Zomming Out
      this._handleZoom(this.newRegion.latitudeDelta * 2,this.newRegion.longitudeDelta * 2)
   }

   render(){
    var props = this.props.googleMaps ? {provider : 'google'} :{}
    return (
        <View style={{flex:1}}>
            <MapView
              {...props}
               style={{flex:1}}
               mapType = 'satellite'
               onPanDrag ={(e)=>{(this.props.drawMode && (FL || FH ))
                                  ? this._handleNewPoint(e.nativeEvent.coordinate)
                                  : null
                                 }}
               zoomEnabled  = {!this.props.drawMode}
               scrollEnabled = {!this.props.drawMode}
               initialRegion = {this.state.region}
               ref = {(MapRef) => {if(MapRef != null){ this.mapReference = MapRef }}}
               loadingEnabled = {true}
               onRegionChangeComplete = {(movedTo) => { this.newRegion = movedTo}}
               animateToRegion = {this._animateToRegion}
               onPress = {(e)=>{(
                  this.props.drawMode &&
                   ( PL || PG || FL || CR || DM ))
                 ? this._handleNewPoint(e.nativeEvent.coordinate)
                 : null
               }}
               >
                  {
                    this.props.shapes.circles.map((eachCircle,i) => {
                      return (
                        <MapView.Circle
                        key = {i}
                        center = {eachCircle.coordinates[0]}
                        radius = {eachCircle.radius}
                        fillColor = {eachCircle.fillColor}
                        strokeColor = 'black'
                        strokeWidth = {1}/>
                      )
                    })
                  }
                  {
                    this.props.shapes.polygons.map((eachPolygon,i) => {
                      if(eachPolygon.coordinates != undefined && eachPolygon.coordinates.length > 3) {
                        if(drawMode) {
                          return (
                            <MapView.Polygon
                              key = {i}
                              onPress ={(e)=>{this._handlePolyOnPress(eachPolygon)}}
                              coordinates = {eachPolygon.coordinates}
                              fillColor = {eachPolygon.fillColor}
                              strokeColor = {eachPolygon.strokeColor}
                              strokeWidth = {eachPolygon.strokeWidth}/>
                          )
                        } else {
                            return (
                              <MapView.Polygon
                                key = {i}
                                //onPress ={(e)=>{this._handlePolyOnPress(eachPolygon)}}
                                coordinates = {eachPolygon.coordinates}
                                fillColor = {eachPolygon.fillColor}
                                strokeColor = {eachPolygon.strokeColor}
                                strokeWidth = {eachPolygon.strokeWidth}/>
                            )
                        }
                      }
                      return null
                    })
                  }
                  {
                    this.props.markers.map((eachMarker,i) => {
                      return (
                        <MapView.Marker
                          image = {eachMarker.image}
                          key = {i}
                          onPress = { ()=>this.props.onMarkerClick(eachMarker) }
                          coordinate = { eachMarker.coordinates }
                          onSelect = { ()=>this.props.onMarkerClick(eachMarker) }
                          />
                      )
                    })
                  }
                  {this._editableMarkersLayer()}
                  {this._draggableMarkersLayer()}
                  {this._drawWithInLayer()}
                  {this._elementsLayer()}
            </MapView>
        </View>
    );
  }
}

AreaSelector.propTypes = {
    shapes : React.PropTypes.object,
    editMode : React.PropTypes.bool,
    drawMode : React.PropTypes.bool,
    drawType : React.PropTypes.string,
    drawWithInShape : React.PropTypes.array,
    pan : React.PropTypes.bool,
    markers : React.PropTypes.array,
    shapes : React.PropTypes.object,
    onMarkerClick : React.PropTypes.func,
    dragglebleMarkers : React.PropTypes.array
 },

 AreaSelector.defaultProps = {
    shapes : {circles:[],polygons:[]},
    editMode : false,
    drawMode : false,
    drawType : 'freeHand',
    drawWithInShape:[],
    markers : [],
    pan : true,
    shapes : {
      polygons:[],
      circles:[]
    },
    dragglebleMarkers : [],
    onMarkerClick:function(e){return e}
}

module.exports = AreaSelector
